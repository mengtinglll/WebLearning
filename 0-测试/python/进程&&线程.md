- [概念](#概念)
  - [线程和进程的区别](#线程和进程的区别)
  - [线程和进程的适用场景和优劣](#线程和进程的适用场景和优劣)
- [进阶](#进阶)
  - [线程的生命周期](#线程的生命周期)
  - [并行与并发](#并行与并发)
  - [同步与异步](#同步与异步)
  - [线程同步安全](#线程同步安全)
  - [死锁、饥饿、活锁](#死锁饥饿活锁)
- [实践](#实践)
  - [Python中的GIL锁](#python中的gil锁)
    - [python和java c++的多线程有什么不同](#python和java-c的多线程有什么不同)
    - [是否适合多线程](#是否适合多线程)
    - [GIL对多线程爬虫的影响](#gil对多线程爬虫的影响)
    - [健壮性](#健壮性)
  - [queue安全队列](#queue安全队列)
  - [多线程的实现](#多线程的实现)
      - [新建threading模块](#新建threading模块)
      - [线程池](#线程池)
      - [线程数的计算](#线程数的计算)
# 概念
1. 进程
- 进程是系统（调度）`资源分配`的基本单位，用来管理资源（例如：内存，文件，网络等资源），操作系统会为每个进程分配一段内存空间；（程序的依次动态执行，经历代码的加载，执行，执行完毕的完整过程）

- 【略】进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。（PCB是描述进程的数据结构）

2. 线程
- 线程是**独立调度**的基本单位。
- 一个进程中可以有多个线程，它们共享进程资源。
- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。
- 处理机分给线程，即真正在处理机上运行的是线程。
- 线程由程序负责管理，进程由系统进行调度
  
QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

## 线程和进程的区别
1. 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

2. 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。

3. 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

4. 通信方面

进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。
## 线程和进程的适用场景和优劣
![a](/img/进程和线程对比.jpg)

# 进阶
## 线程的生命周期
- 【New(新建)】，新创建的线程进过初始化，进入Runnable(就绪)状态。
- 【Runnable(就绪)】，等待线程调度，调度后进入Running(运行)状态。
- 【Running(运行)】，线程正常运行，期间可能会因为某些情况进入Blocked(同步锁；调用了sleep()和join()方法进入Sleeping状态；执行wait()方法进入Waiting状态，等待其他线程notify通知唤醒)。
- 【Blocked(堵塞)】，线程暂停运行，解除堵塞后进入Runnable(就绪)状态重新等待调度
- 【Dead(死亡)】，线程完成了它的任务正常结束或因异常导致终止。

## 并行与并发
并行是同时处理多个任务，而并发则是处理多个任务，而不一定要同时，并行可以说是并发的子集。

## 同步与异步
- 同步：线程执行某个请求，如果该请求需要一段时间才能返回信息，那么这个线程会一直等待，直到收到返回信息才能继续执行下去。
- 异步：线程执行完某个请求，不需要一直等，直接继续执行后续操作，当有消息返回时系统会通知线程进程处理，这样可以提高执行的效率；异步在网络请求的应用非常常见。

## 线程同步安全
- 【问题】当有两个或以上线程在同一时刻访问同一资源时（临界/共享资源），有可能会出现线程安全问题
- 【解决】同一时刻，只能有一个线程访问临界资源，也称"同步互斥访问"
- 【方法】加锁(同步锁)，当有线程访问临界资源时需要获得这个锁，其他线程无法访问，只能等待(堵塞)，等这个线程使用完释放锁，供其他线程继续访问。
  
## 死锁、饥饿、活锁
1. 死锁【线程】
   - 【产生条件】
     - 互斥条件(临界资源，访问同一个资源)
     - 请求和保持条件(请求资源但不释放自己暂用的资源)；
     - 不剥夺条件(线程获得的资源只有线程使用完后自己释放，不能被其他线程剥夺)；
     - 环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，t1等t2，t2等t1；
   - 【解决】
      -  有序资源分配法：资源按某种规则统一编号，申请时必须按照升序申请： 属于同一类的资源要一次申请完，申请不同类资源按照一定的顺序申请。
      -  银行家算法：就是检查申请者对资源的最大需求量，如果当前各类资源都可以满足的 申请者的请求，就满足申请者的请求，这样申请者就可很快完成其计算，然后释放它占用 的资源
2. 饥饿与饿死【进程】
   - 资源分配策略有可能是不公平的，即使没有发生死锁， 某些进程可能因长时间的等待
3. 活锁【进程】
   - 特殊的饥饿，一系列进程轮询等待某个不可能为真的条件为真，此时进程不会进入blocked状态，但会占用CPU资源，活锁还有几率能自己解开





# 实践

## Python中的GIL锁
- 全局解释器锁，用于同步线程的一种机制，使得任何时候仅有一个线程在执行。
- GIL 并不是Python的特性，只是在实现Python解析器(CPython)时引入的一个概念。
- （IronPython，一个基于 。NET 的 Python 实现就没有 GIL，同样的，Jython，基于 Java 的 Python 实现也没有。）
- Python解释器进程内的多线程是以协作多任务方式执行的，当一个线程遇到I/O操作时会释放GIL
- 依赖CPU计算的线程则是使用固定的超时时间来指示当前线程放弃全局锁
- 多线程在处理CPU密集型操作因为各种循环处理计数等，会很快达到阀值，而多个线程来回切换是会消耗资源的，所以多线程的效率往往可能还比不上单线程
- 多核环境下可能出现线程颠簸，导致效率更低。


### python和java c++的多线程有什么不同
- c++和java的线程是对应操作系统内核线程的，也就是在多核cpu的情况下，可以实现真正的并行
- 而在python中，由于GIL，使得任何时候仅有一个线程在执行。一个线程遇到I/O操作时会释放GIL，切换一个线程

### 是否适合多线程
- 单核：
    - 计算密集型：单核，多进程也不能实现，多线程略有，单线程即可
    - IO密集型：多线程
- 多核：
    - 计算密集：多进程多核并计算√，多线程实际只单线程，用不上多核×
    - IO密集：多核解决不了IO问题，故用多线程
### GIL对多线程爬虫的影响
- 对比实验证明，下载速度更快了，但必须指出的是，因为 GIL 的限制，同一时间仍然只有一个线程在执行。代码只是并发执行而不是并行执行
- 其比单线程下载更快的原因是因为下载图片是 IO 密集型的操作。
- 当下载图片时处理器便空闲了下来，处理器花费的时间主要在等待网络连接上。当当前线程开始执行下载任务时，处理器便可以切换到其他线程继续执行。
### 健壮性

## queue安全队列
- Python中的queue模块中已经实现了一个线程安全的（多生产者），多消费者队列，自带锁，常用于多线程并发数据交换。
- 
## 多线程的实现
#### 新建threading模块
- 通过threading模块创建新的线程有两种方法：
- 一种是通过threading.Thread(Target=executable Method)-即传递给Thread对象一个可执行方法（或对象）;
- 第二种是继承threading.Thread定义子类并重写run()方法。第二种方法中，唯一必须重写的方法是run()

```
import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    # init 构造函数
    def __init__(self, threadID, name, ...arg):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.pdf_queue = pdf_queue #等其他参数
    # 一定要重构run方法
    def run(self): #不需要锁
      while true://死循环，直到队列读取完，结束该线程
        // 或while not self.pdf_queue.empty():
        print ("开始线程：" + self.name)
        //执行爬虫程序
        print ("退出线程：" + self.name)
########### main函数（理解）############
# pdf链接 下载队列
pdf_queue = queue.Queue()
    for url in pdf_urls:
        pdf_queue.put(url)
# 开启多线程（池）（方法一，略）
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# 开启新线程（）
thread_list = ['Thread-1', 'Thread-2', 'Thread-3', 'Thread-4']
    threads = []
    for idx, name in enumerate(thread_list):
        thread = MultiDownloader(idx, name, work_dir, pdf_queue, len(pdf_urls))
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()
```
#### 线程池
- 一个线程的运行时间可以分为3部分：线程的启动时间、线程体的运行时间和线程的销毁时间。在多线程处理的情景中，如果线程不能被重用，就意味着每次创建都需要经过启动、销毁和运行3个过程。这必然会增加系统相应的时间，降低了效率。
- 我们把任务放进队列中去，然后开N个线程，每个线程都去队列中取一个任务，执行完了之后告诉系统说我执行完了，然后接着去队列中取下一个任务，直至队列中所有任务取空，退出线程。
- 由于线程预先被创建并放入线程池中，同时处理完当前任务之后并不销毁而是被安排处理下一个任务，因此能够避免多次创建线程，从而节省线程创建和销毁的开销，能带来更好的性能和系统稳定性。
#### 线程数的计算
- 服务器CPU核数有限，能够同时并发的线程数有限，并不是开得越多越好，以及线程切换是有开销的，如果线程切换过于频繁，反而会使性能降低
- 等待IO返回，比如recv(), accept(), sleep()等操作，是不占cpu的
- N核服务器，通过执行业务的单线程分析出本地计算时间为x，等待时间为y，则工作线程数（线程池线程数）设置为 N*(x+y)/x，能让CPU的利用率最大化。 
- 由于有GIL的影响，python只能使用到1个核，所以这里设置N=1
- 【改进】开多进程（4），可以用到本电脑的四个cpu
  